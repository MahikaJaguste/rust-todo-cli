use csv;
use dirs_next::data_local_dir;
use std::fs::{self, OpenOptions};
use std::io::Error;
use std::path::PathBuf;
use todo::{TodoItem, TodoList};

pub fn get_todo_file_path() -> Result<PathBuf, Error> {
    let mut dir = match data_local_dir() {
        Some(dir) => dir,
        None => {
            return Err(Error::new(
                std::io::ErrorKind::NotADirectory,
                "Could not find a local data directory",
            ));
        }
    };

    dir.push("todo_cli");
    match fs::create_dir_all(&dir) {
        Ok(d) => d,
        Err(_) => {
            return Err(Error::new(
                std::io::ErrorKind::NotADirectory,
                "Could not create directory todo_cli",
            ));
        }
    }

    dir.push("todo_list.csv");

    Ok(dir)
}

pub fn load_list(todo_file_path: &PathBuf) -> Result<Vec<TodoItem>, Error> {
    // using ? only when function returns result
    // ? basically returns error in case of Err arm, or does Ok(..) and returns value

    // since these are file operations, error is of type io.Error
    // if we have nothing to return, then Ok(()) returns a Result object with no value
    // if it was Result<bool, ...>, then Ok(true) would work
    let file = OpenOptions::new()
        .write(true)
        .read(true)
        .create(true)
        .open(todo_file_path)?;
    // for create to work, write or append must be enabled

    let mut rdr = csv::Reader::from_reader(file);

    let mut list: Vec<TodoItem> = vec![];

    // if there is error in converting the result to TodoItem, ie. error in parsing
    // that error is of type csv::Error
    // but the return type of our function is std::io::Error
    // csv implements the From trait on io::Error, which has a from(err: Error) method
    //
    // Source:
    // impl From<csv::Error> for io::Error {
    //     fn from(err: csv::Error) -> io::Error {
    //         io::Error::new(io::ErrorKind::Other, err)
    //     }
    // }
    //
    // this method takes in to create an io::Error of kind Other
    // ? calls this from() method to return an io::Error as function result
    for result in rdr.deserialize() {
        // this deserialize call internally uses the impl serde::Deserialize for TodoItem
        // which was automatically generated by deriving it
        // to convert the csv record in TodoItem
        let item: TodoItem = result?;
        list.push(item);
    }

    Ok(list)
}

pub fn save_list(todo_file_path: &PathBuf, todo_list: &TodoList) -> Result<(), Error> {
    let file = OpenOptions::new()
        .write(true)
        .truncate(true)
        .create(true)
        .open(todo_file_path)?;
    // truncate is needed, as if current content is shorter than existing,
    // the leftover characters of original file will not be removed

    let mut wtr = csv::Writer::from_writer(file);

    for item in &todo_list.list {
        // serialise, each row is written/buffered in memory
        wtr.serialize(item)?;
        // internally uses impl serde::Serialize for TodoItem
    }

    // ensures all data (buffered in memory) is persistend onto disk ie. saved in file
    wtr.flush()?;
    Ok(())
}

// unit tests for csv_io
#[cfg(test)]
mod tests {
    use super::*;
    use std::env;
    use std::fs::remove_file;
    use std::io::ErrorKind;
    use todo::{TodoPriority, TodoStatus};

    #[test]
    fn file_path() {
        let todo_file_path = get_todo_file_path();
        assert!(todo_file_path.unwrap().ends_with("todo_cli/todo_list.csv"));
    }

    #[test]
    fn invalid_file_path() {
        let todo_file_path = env::current_dir().unwrap();
        let todo_list = TodoList { list: vec![] };
        assert_eq!(
            save_list(&todo_file_path, &todo_list).unwrap_err().kind(),
            ErrorKind::IsADirectory
        )
    }

    #[test]
    fn list_with_valid_items() {
        let todo_file_path = env::current_dir().unwrap().join("todo_list_valid.csv");

        let list: Vec<TodoItem> = vec![
            TodoItem {
                title: String::from("task1"),
                priority: TodoPriority::High,
                status: TodoStatus::Pending,
            },
            TodoItem {
                title: String::from("task2"),
                priority: TodoPriority::Low,
                status: TodoStatus::Done,
            },
        ];

        let todo_list = TodoList { list: list };

        assert!(save_list(&todo_file_path, &todo_list).is_ok());

        let loaded_list = load_list(&todo_file_path).unwrap();

        assert_eq!(todo_list, TodoList { list: loaded_list });

        let _ = remove_file(&todo_file_path);
    }

    #[test]
    fn list_with_invalid_items() {
        let todo_file_path = env::current_dir().unwrap().join("todo_list_invalid.csv");

        let file = OpenOptions::new()
            .write(true)
            .truncate(true)
            .create(true)
            .open(&todo_file_path)
            .unwrap();

        let mut wtr = csv::Writer::from_writer(file);

        let _ = wtr.write_record(&["title", "priority", "status"]);
        _ = wtr.write_record(&["task1", "Nan", "Pending"]);
        _ = wtr.write_record(&["task2"]);

        wtr.flush().unwrap();

        assert_eq!(
            load_list(&todo_file_path).unwrap_err().kind(),
            ErrorKind::Other
        );

        let _ = remove_file(&todo_file_path);
    }
}
